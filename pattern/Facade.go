package pattern

import (
	"fmt"
	"strings"
)

//Паттерн "Фасад"

//Примером реализации фасада будет человек, которому доступно множество функций, но мы реализуем только базовые:
//Посадить дерево, построить дом и вырастить сына

// man Наш фасад
type man struct {
	tree  *tree
	house *cottage
	son   *son
}

func (m *man) toDoFacade() string {
	result := []string{
		m.house.toBuild(),
		m.tree.toPlant(),
		m.son.toGrow(),
	}
	return strings.Join(result, "\n")
}

// Tree имплементация дерева
type tree struct {
}

func (t *tree) toPlant() string {
	return "Plant a Tree"
}

// House имплементация дома
type cottage struct {
}

func (c *cottage) toBuild() string {
	return "Build House"
}

// Son имплементация сына
type son struct {
}

func (s *son) toGrow() string {
	return "Grow a Son"
}

//реализация паттерна
func FacadePattern() {
	man := &man{}
	fmt.Println(man)
}

/*
	Применяемость:
	- Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
	- Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению
	меньших классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз
	под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает
	определённый вид системы по умолчанию, устраивающий большинство клиентов.

	- Когда вы хотите разложить подсистему на отдельные слои.
	- Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга,
	то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

	Плюсы:
	- Изолирует клиентов от компонентов сложной подсистемы.
	Минусы:
	- Фасад рискует стать "божественным объектом", привязанным ко всем классам программы.
*/
